"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  RateLimit: () => RateLimit,
  RateLimitManager: () => RateLimitManager
});

// src/lib/RateLimit.ts
var RateLimit = class {
  constructor(manager) {
    __publicField(this, "remaining");
    __publicField(this, "expires");
    __publicField(this, "manager");
    this.manager = manager;
    this.reset();
  }
  get expired() {
    return this.remainingTime === 0;
  }
  get limited() {
    return this.remaining === 0 && !this.expired;
  }
  get remainingTime() {
    return Math.max(this.expires - Date.now(), 0);
  }
  consume() {
    if (this.limited)
      throw new Error("Cannot consume a limited bucket");
    if (this.expired)
      this.reset();
    this.remaining--;
    return this;
  }
  reset() {
    return this.resetRemaining().resetTime();
  }
  resetRemaining() {
    this.remaining = this.manager.limit;
    return this;
  }
  resetTime() {
    this.expires = Date.now() + this.manager.time;
    return this;
  }
};
__name(RateLimit, "RateLimit");

// src/lib/RateLimitManager.ts
var import_time_utilities = require("@sapphire/time-utilities");
var _RateLimitManager = class extends Map {
  constructor(time, limit = 1) {
    super();
    __publicField(this, "time");
    __publicField(this, "limit");
    __publicField(this, "sweepInterval");
    this.time = time;
    this.limit = limit;
  }
  acquire(id) {
    return this.get(id) ?? this.create(id);
  }
  create(id) {
    const value = new RateLimit(this);
    this.set(id, value);
    return value;
  }
  set(id, value) {
    this.sweepInterval ?? (this.sweepInterval = import_time_utilities.TimerManager.setInterval(this.sweep.bind(this), _RateLimitManager.sweepIntervalDuration));
    return super.set(id, value);
  }
  sweep() {
    for (const [id, value] of this.entries()) {
      if (value.expired)
        this.delete(id);
    }
    if (this.size === 0) {
      import_time_utilities.TimerManager.clearInterval(this.sweepInterval);
      this.sweepInterval = null;
    }
  }
};
var RateLimitManager = _RateLimitManager;
__name(RateLimitManager, "RateLimitManager");
__publicField(RateLimitManager, "sweepIntervalDuration", 3e4);
module.exports = __toCommonJS(src_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  RateLimit,
  RateLimitManager
});
//# sourceMappingURL=index.js.map