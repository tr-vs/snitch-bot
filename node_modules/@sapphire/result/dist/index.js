"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  err: () => err,
  from: () => from,
  fromAsync: () => fromAsync,
  isErr: () => isErr,
  isMaybe: () => isMaybe,
  isNone: () => isNone,
  isOk: () => isOk,
  isSome: () => isSome,
  maybe: () => maybe,
  none: () => none,
  ok: () => ok,
  some: () => some
});

// src/lib/Maybe.ts
function maybe(value) {
  return isMaybe(value) ? value : value === null ? none() : some(value);
}
__name(maybe, "maybe");
function some(x) {
  return { exists: true, value: x };
}
__name(some, "some");
function none() {
  return { exists: false };
}
__name(none, "none");
function isSome(x) {
  return x.exists;
}
__name(isSome, "isSome");
function isNone(x) {
  return !x.exists;
}
__name(isNone, "isNone");
function isMaybe(x) {
  return typeof x === "object" && x !== null && typeof Reflect.get(x, "exists") === "boolean";
}
__name(isMaybe, "isMaybe");

// src/lib/Result.ts
function ok(x) {
  return { success: true, value: x };
}
__name(ok, "ok");
function err(x) {
  return { success: false, error: x };
}
__name(err, "err");
function isOk(x) {
  return x.success;
}
__name(isOk, "isOk");
function isErr(x) {
  return !x.success;
}
__name(isErr, "isErr");

// src/lib/Parsers.ts
function from(cb) {
  try {
    return ok(cb());
  } catch (error) {
    return err(error);
  }
}
__name(from, "from");
async function fromAsync(promiseOrCb) {
  try {
    return ok(await (isFunction(promiseOrCb) ? promiseOrCb() : promiseOrCb));
  } catch (error) {
    return err(error);
  }
}
__name(fromAsync, "fromAsync");
function isFunction(input) {
  return typeof input === "function";
}
__name(isFunction, "isFunction");
module.exports = __toCommonJS(src_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  err,
  from,
  fromAsync,
  isErr,
  isMaybe,
  isNone,
  isOk,
  isSome,
  maybe,
  none,
  ok,
  some
});
//# sourceMappingURL=index.js.map